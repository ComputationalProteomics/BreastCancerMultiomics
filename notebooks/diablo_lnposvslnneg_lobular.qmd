---
title: "DIABLO - Lymph Node Positive vs Negative Lobular"
author: "Sergio Mosquim Junior"
format:
  html:
    toc: true
    code-fold: true
    embed-resources: true
    toc-location: left
    smooth-scroll: true
    message: false
engine: knitr
---

# Requires Packages:

```{r required packages}
#| message: false
#| warning: false
library(tidyverse)
library(mixOmics)
library(tidymodels)
library(future)
library(furrr)
library(BiocParallel)
library(parallel)
library(tictoc)
library(future.callr)
library(igraph)
source(file = '/Users/analysis/Desktop/Sergio/multiomics/notebooks/medianFiltering.R',chdir = TRUE)
```
```{r}
workers <- availableCores(constraints = 'connections',which = 'min')
plan(callr,workers=workers)
on.exit(expr = {plan(sequential)})
```


# DIABLO model

```{r, Setting results directory}
if(!dir.exists(paths = '/Users/analysis/Desktop/Sergio/multiomics/results/DIABLO/LNposvsLNneg/Lobular')) {
  dir.create(path = '/Users/analysis/Desktop/Sergio/multiomics/results/DIABLO/LNposvsLNneg/Lobular',recursive = TRUE)
}

if(!dir.exists(paths = '/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular')) {
  dir.create(path = '/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular',recursive = TRUE)
}
```

## Create training and test datasets
```{r}
#| message: false
set.seed(123)
design <- read_tsv('/Users/analysis/Desktop/Sergio/multiomics/results/design_files/design_multiomics_mofa.tsv') %>% 
  dplyr::filter(InvCa.type=='Lobular')
```

## Load data and create multiomics data matrix
```{r}
#| message: false
proteindata <- read_tsv(file = '/Users/analysis/Desktop/Sergio/multiomics/results/batchcorrection/fullproteome/cycloess_rollup_genes_batchcorrected.tsv') %>% 
  NAFiltering(design = design,sampleCol = 'sample_id',cutoff = 0.3) %>% 
  medianFiltering(design = design,sampleCol = 'sample_id',annotation = 'Protein',cutoff = 0.75)
prot <- proteindata %>% 
  dplyr::select(design$sample_id) %>% 
  t()
colnames(prot) <- make.names(names = proteindata$Protein.Names,unique = TRUE)

phosphodata <- read_tsv(file = '/Users/analysis/Desktop/Sergio/multiomics/results/batchcorrection/phosphoproteome/cycloess_peptide_batchcorrected.tsv') %>% 
  NAFiltering(design = design,sampleCol = 'sample_id',cutoff = 0.3) %>% 
  medianFiltering(design = design,sampleCol = 'sample_id',annotation = 'Precursor.Id',cutoff = 0.5)
phospho <- phosphodata %>% 
  dplyr::select(design$sample_id) %>% 
  t()
colnames(phospho) <- make.names(names = phosphodata$Protein.Names,unique = TRUE)


genedata <- read_tsv(file = '/Users/analysis/Desktop/Sergio/multiomics/data/transcriptomics/genematrix_filtered_adjusted_centered.tsv') %>% 
  NAFiltering(design = design,sampleCol = 'sample_id',cutoff = 0.5) %>% 
  medianFiltering(design = design,sampleCol = 'sample_id',annotation = 'Gene.ID',cutoff = 0.75)
gene <- genedata %>% 
  dplyr::select(design$sample_id) %>% 
  t()
colnames(gene) <- make.names(names = genedata$Gene.Name,unique = TRUE)


response <- factor(design$LN)

data <- list(proteomics=prot,
                phosphoproteomics=phospho,
                transcriptomics=gene)

varKeep <- c('data','response','medianFiltering','NAFiltering','design','workers')
rm(list = setdiff(ls(),varKeep))
```

## Setup
```{r}
list.keepX = c(100, 100) # select arbitrary values of features to keep
list.keepY = c(100,100)
set.seed(123)
# generate three pairwise PLS models
pls1 <- spls(data[["proteomics"]], data[["transcriptomics"]], 
             keepX = list.keepX, keepY = list.keepY) 
pls2 <- spls(data[["proteomics"]], data[["phosphoproteomics"]], 
             keepX = list.keepX, keepY = list.keepY)
pls3 <- spls(data[["phosphoproteomics"]], data[["transcriptomics"]], 
             keepX = list.keepX, keepY = list.keepY)
```
### Correlation between pairs of omics
```{r}
cor(pls1$variates$X, pls1$variates$Y)

cor(pls2$variates$X, pls2$variates$Y) 

cor(pls3$variates$X, pls3$variates$Y) 
```

### Generate basic model
### Evaluate optimal number of components
### Design matrix for DIABLO
```{r}
# run component number tuning with repeated CV
set.seed(123)
tic()
perf.diablo <- future(seed = TRUE,globals = TRUE,packages = c('mixOmics'),gc = TRUE,
                      expr = {
                        design <- matrix(0.1,
                                         ncol = length(data), 
                                         nrow = length(data),
                                         dimnames = list(names(data),names(data)))
                        diag(design) <- 0
                        basic.diablo.model %<-% block.splsda(X = data, Y = response, ncomp = 15, design = design) 
                        perf(basic.diablo.model, validation = 'Mfold',folds= 5, nrepeat=100,progressBar = TRUE,cpus=workers)
                        }
                      )
perf.diablo <- value(perf.diablo)
toc()
```

```{r}
plot(perf.diablo)
# show the optimal choice for ncomp for each dist metric
perf.diablo$choice.ncomp$WeightedVote 

# set the optimal ncomp value
ncomp <-  perf.diablo$choice.ncomp$WeightedVote["Overall.BER", "max.dist"] 
```
## Model Tuning
```{r}
BPPARAM = BiocParallel::SnowParam(RNGseed = 123,workers = 60)
design <- matrix(0.1,ncol = length(data),nrow = length(data),dimnames = list(names(data),names(data)))
diag(design) <- 0
# set grid of values for each component to test
test.keepX <- list(proteomics = c(seq(10,100,10)),
                   phosphoproteomics = c(seq(10,100,10)),
                   transcriptomics = c(seq(10,100,10)))

# run the feature selection tuning
tune.diablo <- tune.block.splsda(X = data,Y = response,ncomp = ncomp,
                                 test.keepX = test.keepX,
                                 folds = 5,nrepeat = 100,validation = 'Mfold',
                                 dist = 'max.dist',
                                 progressBar = TRUE, design = design,BPPARAM = BPPARAM)

```

### Optimal number of features to keep
```{r}
list.keepX <- tune.diablo$choice.keepX # set the optimal values of features to keep
ncomp <- tune.diablo$choice.ncomp$ncomp
```
### Second round of tuning
```{r}
test.keepX <- list(proteomics = c(1:4,seq(5,20,5)),
                   phosphoproteomics = c(1:4,seq(5,20,5)),
                   transcriptomics = c(1:4,seq(5,20,5)))

# run the feature selection tuning
tune.diablo2 <- tune.block.splsda(X = data,Y = response,ncomp = ncomp,
                                 test.keepX = test.keepX,
                                 folds = 5,nrepeat = 100,validation = 'Mfold',
                                 dist = 'max.dist',
                                 progressBar = TRUE, design = design,BPPARAM = BPPARAM)

```

### Final model
```{r}
final.diablo.tune1 <- block.splsda(X = data, Y = response, ncomp = 6, 
                          keepX = list.keepX, design = design)
final.diablo.tune2 <- block.splsda(X = data, Y = response, ncomp = 4, 
                          keepX = tune.diablo2$choice.keepX, design = design)

final.diablo.tune3 <- block.splsda(X = data,Y = response,ncomp = tune.diablo2$choice.ncomp$ncomp,
                                   keepX = purrr::map(tune.diablo2$choice.keepX,~.x[1:2]),design = design)


models <- list(final.diablo.tune1,final.diablo.tune2,final.diablo.tune3)
purrr::map2(.x = models,.y = c('lobular.tune1','lobular.tune2','lobular.tune3'),function(model,name){
  saveRDS(object = model,file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/DIABLO/LNposvsLNneg/Lobular/',name,'.gzip'),compress = 'gzip')
})
```

## Table of selected variables
```{r}
modelVar <- purrr::map(.x = models,function(model){
  ncomp <- model[['ncomp']][['Y']]
  modelVar <- purrr::map(.x = 1:ncomp,.f = ~selectVar(model,comp=.x))
  names(modelVar) <- paste0('Comp',1:ncomp)
  modelVar <- purrr::map(1:ncomp,function(x){
    proteomics <- pluck(modelVar,x,'proteomics','name')
    phosphoproteomics <- pluck(modelVar,x,'phosphoproteomics','name')
    transcriptomics <- pluck(modelVar,x,'transcriptomics','name')
    list(proteomics=proteomics,phosphoproteomics=phosphoproteomics,transcriptomics=transcriptomics)
    })
  names(modelVar) <- paste0('Comp',1:ncomp)
  modelVar <- modelVar %>% 
    map_depth(.,2,~data.frame(ID=.x)) %>% 
    map_depth(.,1,~list_rbind(.x,names_to = 'Omics')) %>% 
    list_rbind(names_to = 'Comp')
  return(modelVar)
  })

purrr::map2(.x = modelVar,.y = c('lobular.tune1','lobular.tune2','lobular.tune3'),function(model,name){
  write_tsv(x = model,paste0('/Users/analysis/Desktop/Sergio/multiomics/results/DIABLO/LNposvsLNneg/Lobular/',name,'_variables','.tsv'))
  })
```

## Figures
### Market Plot
```{r}
#| message: false
#| eval: false

# This gives an error whenever a model has a single variable in a component
purrr::map2(.x = models,
            .y = c('lobular.tune1','lobular.tune2','lobular.tune3'),
            function(model,name){
              ncomp <- model[['ncomp']][['Y']]
              pdf(file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_markerPlot','.pdf'),width =30,height = 10,onefile = TRUE)
              purrr::map(1:ncomp,~plotMarkers(object = model,block = 'proteomics',comp = .x))
              purrr::map(1:ncomp,~plotMarkers(object = model,block = 'phosphoproteomics',comp = .x))
              purrr::map(1:ncomp,~plotMarkers(object = model,block = 'transcriptomics',comp = .x))
              dev.off()
              }
            )
```



### DIABLO Plot
```{r}
purrr::map2(.x = models,
            .y = c('lobular.tune1','lobular.tune2','lobular.tune3'),
            function(model,name){
              ncomp <- model[['ncomp']][['Y']]
              pdf(file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_corrPlot','.pdf'),width = 10,height = 10,onefile = TRUE)
              purrr::map(1:ncomp,~plotDiablo(model,ncomp = .x,legend = TRUE))
              dev.off()
              }
            )
```


### Circos Plot
```{r}
#| message: false
#| warning: false
purrr::map2(.x = models,
            .y = c('lobular.tune1','lobular.tune2','lobular.tune3'),
            function(model,name){
              pdf(file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_circosPlot','.pdf'),onefile = TRUE,width = 8.5)
              circosPlot(model, cutoff = 0.7, line = TRUE,
                         color.blocks= c('darkorchid', 'brown1', 'lightgreen'),
                         color.cor = c("chocolate3","grey20"),
                         size.labels = 1,
                         size.variables = 0.3,
                         legend = TRUE)
              dev.off()
            }
)
```

### Network Plot
```{r}
#| message: false
#| warning: false
purrr::map2(.x = models,
            .y = c('lobular.tune1','lobular.tune2','lobular.tune3'),
            function(model,name){
              pdf(file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_networkPlot','.pdf'),width = 30,height = 30,compress = TRUE)
              networkResult <- network(model,
                      blocks = c('proteomics','phosphoproteomics','transcriptomics'),
                      color.node = c('proteomics'='darkorchid', 'phosphoproteomics'='brown1', 'transcriptomics'='lightgreen'),
                      cutoff = abs(0.82),
                      size.node = 0.001,
                      graph.scale = 1)
              dev.off()
              write_graph(graph = networkResult$gR,file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_networkPlot','.gml'),format = 'gml')
            }
)
```

### Loadings Plot
```{r}
#| message: false
#| warning: false
purrr::map2(.x = models,
            .y = c('lobular.tune1','lobular.tune2','lobular.tune3'),
            function(model,name){
              ncomp <- model[['ncomp']][['Y']]
              pdf(file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_LoadingsPlot','.pdf'),onefile = TRUE,width = 20,height = 20)
              modelContributions <- purrr::map(1:ncomp,~plotLoadings(model,comp = .x, contrib = 'max', method = 'median'))
              dev.off()
            }
)
```


### Heatmap
```{r}
#| message: false
#| warning: false
purrr::map2(.x = models,
            .y = c('lobular.tune1','lobular.tune2','lobular.tune3'),
            function(model,name){
              ncomp <- model[['ncomp']][['Y']]
              pdf(file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_heatmap','.pdf'),onefile = TRUE,width = 10,height = 10)
              diabloHeatmap <- purrr::map(1:ncomp,~cimDiablo(model,transpose = TRUE,comp = .x,margins = c(5,25),legend.position = 'topright',size.legend = 1))
              dev.off()
            }
)
```

### Plot AUC
```{r}
#| message: false
#| warning: false
purrr::map2(.x = models,
            .y = c('lobular.tune1','lobular.tune2','lobular.tune3'),
            function(model,name){
              pdf(file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_AUC','.pdf'),onefile = TRUE,width = 10,height = 10)
              auc.splsda = auroc(model,roc.block = c('proteomics','phosphoproteomics','transcriptomics'))
              dev.off()
            }
)
```

## Model Evaluation
```{r}
#| message: false
#| warning: false
set.seed(123)
purrr::map2(.x = models,
            .y = c('lobular.tune1','lobular.tune2','lobular.tune3'),
            function(model,name){
              perf.diablo <- perf(model, validation = 'Mfold',M = 5, nrepeat = 10,cpus = 60)
              pdf(file = paste0('/Users/analysis/Desktop/Sergio/multiomics/results/figures/DIABLO/LNposvsLNneg/Lobular/',name,'_performance','.pdf'))
              plot(perf.diablo)
              dev.off()
            }
)

```

## Model Prediction on Test data
```{r}
predict.diablo = predict(final.diablo.model, newdata = dataTest)
confusion.mat = get.confusion_matrix(truth = responseTest,
                     predicted = predict.diablo$WeightedVote$centroids.dist)
confusion.mat
```

