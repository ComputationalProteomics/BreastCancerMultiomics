---
title: "DIABLO Group1 vs Group2"
author: "Sergio Mosquim Junior"
format:
  html:
    toc: true
    code-fold: true
    embed-resources: true
    toc-location: left
    smooth-scroll: true
    message: false
engine: knitr
---

# Requires Packages:

```{r required packages}
#| message: false
#| warning: false
library(tidyverse)
library(mixOmics)
library(tidymodels)
source(file = '~/multiomics/notebooks/medianFiltering.R',chdir = TRUE)
```


# DIABLO model

```{r, Setting results directory}
if(!dir.exists(paths = '~/multiomics/results/DIABLO/Group1vsGroup1')) {
  dir.create(path = '~/multiomics/results/DIABLO/Group1vsGroup1',recursive = TRUE)
}

if(!dir.exists(paths = '~/multiomics/results/figures/DIABLO/Group1vsGroup1')) {
  dir.create(path = '~/multiomics/results/figures/DIABLO/Group1vsGroup1',recursive = TRUE)
}
```

## Create training and test datasets
```{r}
set.seed(123)
design <- read_tsv('~/multiomics/results/design_files/design_multiomics_mofa.tsv') %>% 
  filter(str_detect(Group.Info,'Group[1,2]'))
dataSplit <- initial_split(data = design,prop = 0.7,strata = 'Group.Info')
trainData <- training(dataSplit)
testData <- testing(dataSplit)
```

## Load data and create multiomics data matrix
```{r}
proteindata <- read_tsv(file = '~/multiomics/results/batchcorrection/fullproteome/cycloess_rollup_genes_batchcorrected.tsv') %>% 
  NAFiltering(design = design,sampleCol = 'sample_id') %>% 
  medianFiltering(design = design,sampleCol = 'sample_id',annotation = 'Protein',cutoff = 0.75)
protTrain <- proteindata %>% 
  dplyr::select(trainData$sample_id) %>% 
  t()
colnames(protTrain) <-make.names(names = proteindata$Protein.Names,unique = TRUE)
protTest <- proteindata %>% 
  dplyr::select(testData$sample_id) %>% 
  t()
colnames(protTest) <-make.names(names = proteindata$Protein.Names,unique = TRUE)


phosphodata <- read_tsv(file = '~/multiomics/results/batchcorrection/phosphoproteome/cycloess_peptide_batchcorrected.tsv') %>% 
  NAFiltering(design = design,sampleCol = 'sample_id') %>% 
  medianFiltering(design = design,sampleCol = 'sample_id',annotation = 'Protein.Group',cutoff = 0.75)
phosphoTrain <- phosphodata %>% 
  dplyr::select(trainData$sample_id) %>% 
  t()
colnames(phosphoTrain) <- make.names(names = phosphodata$Protein.Names,unique = TRUE)
phosphoTest <- phosphodata %>% 
  dplyr::select(testData$sample_id) %>% 
  t()
colnames(phosphoTest) <- make.names(names = phosphodata$Protein.Names,unique = TRUE)


genedata <- read_tsv(file = '~/multiomics/data/transcriptomics/genematrix_filtered_adjusted_centered.tsv') %>% 
  NAFiltering(design = design,sampleCol = 'sample_id') %>% 
  medianFiltering(design = design,sampleCol = 'sample_id',annotation = 'Gene.ID',cutoff = 0.75)
geneTrain <- genedata %>% 
  dplyr::select(trainData$sample_id) %>% 
  t()
colnames(geneTrain) <- make.names(names = genedata$Gene.Name,unique = TRUE)
geneTest <- genedata %>% 
  dplyr::select(testData$sample_id) %>% 
  t()
colnames(geneTest) <- make.names(names = genedata$Gene.Name,unique = TRUE)



responseTrain <- factor(trainData$Group.Info)
responseTest <- factor(testData$Group.Info)

dataTrain <- list(proteomics=protTrain,
                phosphoproteomics=phosphoTrain,
                transcriptomics=geneTrain)

dataTest <- list(proteomics=protTest,
                phosphoproteomics=phosphoTest,
                transcriptomics=geneTest)

varKeep <- c('dataTest','dataTrain','responseTrain','responseTest')
rm(list = setdiff(ls(),varKeep))
```


## Setup
```{r}
list.keepX = c(25, 25) # select arbitrary values of features to keep
list.keepY = c(25, 25)

# generate three pairwise PLS models
pls1 <- spls(dataTrain[["proteomics"]], dataTrain[["transcriptomics"]], 
             keepX = list.keepX, keepY = list.keepY) 
pls2 <- spls(dataTrain[["proteomics"]], dataTrain[["phosphoproteomics"]], 
             keepX = list.keepX, keepY = list.keepY)
pls3 <- spls(dataTrain[["phosphoproteomics"]], dataTrain[["transcriptomics"]], 
             keepX = list.keepX, keepY = list.keepY)
```

### Correlation between pairs of omics
```{r}
cor(pls1$variates$X, pls1$variates$Y)

cor(pls2$variates$X, pls2$variates$Y) 

cor(pls3$variates$X, pls3$variates$Y) 
```
### Design matrix for DIABLO
```{r}
# for square matrix filled with 0.1s
design <- matrix(0.1, ncol = length(dataTrain), nrow = length(dataTrain), 
                dimnames = list(names(dataTrain), names(dataTrain)))
diag(design) = 0 # set diagonal to 0s

design
```
### Generate basic model
```{r}
basic.diablo.model <- block.splsda(X = dataTrain, Y = responseTrain, ncomp = 15, design = design) 
```

### Evaluate optimal number of components
```{r}
# run component number tuning with repeated CV
perf.diablo <-  perf(basic.diablo.model, validation = 'Mfold', 
                   folds = 10, nrepeat = 10,progressBar = TRUE,auc = TRUE,cpus = (parallel::detectCores()-2)) 

plot(perf.diablo) # plot output of tuning
```

```{r}
# set the optimal ncomp value
ncomp <-  perf.diablo$choice.ncomp$WeightedVote["Overall.BER", "centroids.dist"] 
# show the optimal choice for ncomp for each dist metric
perf.diablo$choice.ncomp$WeightedVote 
ncomp
```
## Model Tuning
```{r}
# set grid of values for each component to test
test.keepX <- list(proteomics = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   phosphoproteomics = c(5:9, seq(10, 18, 2), seq(20,30,5)),
                   transcriptomics = c(5:9, seq(10, 18, 2), seq(20,30,5)))

# run the feature selection tuning
tune.diablo <- tune.block.splsda(X = dataTrain,Y = responseTrain,ncomp = ncomp,
                                 test.keepX = test.keepX,
                                 folds = 10,nrepeat = 1,validation = 'Mfold',
                                 dist = 'centroids.dist',
                                 progressBar = TRUE, design = design,
                                 BPPARAM = BiocParallel::MulticoreParam(workers = parallel::detectCores()-2))
```

### Optimal number of features to keep
```{r}
list.keepX <- tune.diablo$choice.keepX # set the optimal values of features to keep
```

### Final model
```{r}
final.diablo.model <- block.splsda(X = dataTrain, Y = responseTrain, ncomp = ncomp, 
                          keepX = list.keepX, design = design)
saveRDS(object = final.diablo.model,file = '~/multiomics/results/DIABLO/Group1vsGroup1/model.gzip',compress = 'gzip')
```

## Table of selected variables
```{r}
ncomp <- final.diablo.model$ncomp[['Y']]
modelVar <- map(.x = 1:ncomp,.f = ~selectVar(final.diablo.model,comp=.x))
names(modelVar) <- paste0('Comp',1:ncomp)
modelVar <- map(1:ncomp,function(x){
  proteomics <- pluck(modelVar,x,'proteomics','name')
  phosphoproteomics <- pluck(modelVar,x,'phosphoproteomics','name')
  transcriptomics <- pluck(modelVar,x,'transcriptomics','name')
  list(proteomics=proteomics,phosphoproteomics=phosphoproteomics,transcriptomics=transcriptomics)
})
names(modelVar) <- paste0('Comp',1:ncomp)
modelVar <- modelVar %>% 
  map_depth(.,2,~data.frame(ID=.x)) %>% 
  map_depth(.,1,~list_rbind(.x,names_to = 'Omics')) %>% 
  list_rbind(names_to = 'Comp')

write_tsv(x = modelVar,file = '~/multiomics/results/DIABLO/Group1vsGroup1/model_variables.tsv')
```

## Figures
### Market Plot
```{r,message=FALSE}
pdf(file = '~/multiomics/results/figures/DIABLO/Group1vsGroup1/marker_plot.pdf',width = 30,height = 10,onefile = TRUE)
map(1:ncomp,~plotMarkers(object = final.diablo.model,block = 'proteomics',comp = .x))
map(1:ncomp,~plotMarkers(object = final.diablo.model,block = 'phosphoproteomics',comp = .x))
map(1:ncomp,~plotMarkers(object = final.diablo.model,block = 'transcriptomics',comp = .x))
dev.off()
```


### DIABLO Plot
```{r}
pdf(file = '~/multiomics/results/figures/DIABLO/Group1vsGroup1/corrplot.pdf',width = 10,height = 10,onefile = TRUE)
map(1:ncomp,~plotDiablo(final.diablo.model,ncomp = .x,legend = TRUE))
dev.off
```

### Sample Plot
```{r}
combinations <- combn(x = ncomp,m = 2,simplify = FALSE)
pdf(file = '~/multiomics/results/figures/DIABLO/Group1vsGroup1/indiv_plot.pdf',width = 10,height = 10,onefile = TRUE)
samplePlot <- map(.x = combinations,~plotIndiv(final.diablo.model,comp = .x, ind.names = FALSE, legend = TRUE,ellipse = TRUE,ellipse.level = 0.95,title = 'DIABLO Sample Plots'))
dev.off()
```

### Circos Plot
```{r}
pdf(file = '~/multiomics/results/figures/DIABLO/Group1vsGroup1/circos_plot.pdf',onefile = TRUE,width = 8.5)
circosPlot(final.diablo.model, cutoff = 0.9, line = TRUE,
           color.blocks= c('darkorchid', 'brown1', 'lightgreen'),
           color.cor = c("chocolate3","grey20"),
           size.labels = 1,
           size.variables = 0.3,
           legend = TRUE)
dev.off()
```

### Network Plot
```{r}
pdf(file = '~/multiomics/results/figures/DIABLO/Group1vsGroup1/network_plot.pdf',onefile = TRUE,width = 20,height = 20)
network(final.diablo.model,
        blocks = c('proteomics','phosphoproteomics','transcriptomics'),
        color.node = c('proteomics'='darkorchid', 'phosphoproteomics'='brown1', 'transcriptomics'='lightgreen'),
        cutoff = abs(0.8),
        size.node = 0.1,
        graph.scale = 0.3)
dev.off()
```

### Loadings Plot
```{r}
pdf(file = '~/multiomics/results/figures/DIABLO/Group1vsGroup1/loadings_plot.pdf',onefile = TRUE,width = 20,height = 20)
modelContributions <- map(1:ncomp,~plotLoadings(final.diablo.model,comp = .x, contrib = 'max', method = 'median'))
dev.off()
```


### Heatmap
```{r}
pdf(file = '~/multiomics/results/figures/DIABLO/Group1vsGroup1/heatmap.pdf',onefile = TRUE,width = 10,height = 10)
diabloHeatmap <- map(1:ncomp,~cimDiablo(final.diablo.model,transpose = TRUE,comp = .x,margins = c(5,25),legend.position = 'topright',size.legend = 1))
dev.off()
```

### Plot AUC
```{r}
pdf(file = '~/multiomics/results/figures/DIABLO/Group1vsGroup1/roc_curve.pdf',onefile = TRUE,width = 10,height = 10)
auc.splsda = auroc(final.diablo.model,roc.block = c('proteomics','phosphoproteomics','transcriptomics'),newdata = dataTest,outcome.test = responseTest, print = FALSE)
dev.off()
```

## Model Evaluation
```{r}
# run repeated CV performance evaluation
perf.diablo <- perf(final.diablo.model, validation = 'Mfold', 
                   M = 10, nrepeat = 10, 
                   dist = 'centroids.dist',cpus = parallel::detectCores()-2) 

perf.diablo$MajorityVote.error.rate
```

## Model Prediction on Test data
```{r}
predict.diablo = predict(final.diablo.model, newdata = dataTest)
confusion.mat = get.confusion_matrix(truth = responseTest,
                     predicted = predict.diablo$WeightedVote$centroids.dist[,2])
confusion.mat
```

